<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="/styles.css" />
    <title>ezcli/structure</title>
  </head>

  <body>
    <section>
      <h1>ezcli/structure</h1>

      <p>
        this is information on how you should probably be structuring your
        project that uses ezcli as it progresses. obviously opinionated, but
        take a look at
        <code>src/examples/calc.c</code>. doesn't that code smell to you?
      </p>

      <p>
        it's supposed to be a proof of concept. but you probably agree that
        stacking a shit ton of <code>ret_e</code> and
        <code>opt_s</code> definitions look REALLY ugly. and options using
        <code>cli_s</code> as context forcibly being inside
        <code>main()</code> and others not? ugh. gross.
      </p>
    </section>

    <section>
      <p>
        if i was going to create a project that needs to scale using ezcli,
        here's how i'd do it:
      </p>

      <pre><code>
app/
├── src/
│ ├── main.c
│ ├── ctx/
│ │ ├── tmp/
│ │ │ ├── state1.h
│ │ │ └── state2.h
│ │ ├── stay/
│ │ │ ├── state1.h
│ │ │ └── state2.h
│ │ └── live/
│ │ │ ├── state1.h
│ │ │ └── state2.h
│ ├── cli/
│ │ ├── ctx.c
│ │ ├── opt1.c
│ │ └── opt2.c
│ └── core/
│ ├── init.c
│ ├── run.c
│ ├── die.c
│ ├── func1.c
│ └── func2.c
└── include/
└── app/
├── cli/
│ ├── opt1.h
│ └── opt2.h
│ └── .
│ └── .
│ └── .
└── core/
├── func1.h
└── func2.h
└── .
└── .
└── .
    </code></pre>
    </section>

        <section>
            
            <h2><code>main.c</code></h2>
            <p>
                is where the program's lifecycle happens. it should be no more than 3
                function calls and a <code>return 0;</code> statement.
            </p>

        </section>
        <section>
            
            <h2>in <code>ctx/</code>:</h2>
            <p>
                contexts in <code>ctx/tmp/</code> are states that are supposed to be
                temporary and should have a specific lifetime.
            </p>

            <p>
                contexts in <code>ctx/live/</code> are states that are supposed to persist
                until the end of the program. these can be heap allocated memory pieces
                that are freed in <code>die()</code>.
            </p>

            <p>
                contexts in <code>ctx/stay/</code> are states that are supposed to persist
                across sessions. these are most likely configurations or some sort of
                authentication key for having accounts for your program (which sounds
                crazy).
            </p>

            <p>
                although, this tmp&lt;live&lt;stay implementation could be skipped if the
                program isn't large enough.
            </p>

        </section>
        <section>
            
            <p>
                we have headers for our different types of context data types. generally,
                these would be structs populated with fields for different purposes.
            </p>

            <p>
                for example: keeping track of permissions, program modes, the sum for a
                calculator, user generated content, encryption keys, etc.
            </p>
        </section>

        <section>
            <h2>in <code>cli/</code>:</h2>
            <p><code>ctx.c</code> initializes and exports all context.</p>
        </section>

        <section>
            <h2><code>optx.c</code>:</h2>
            <p>
                <code>optx.c</code> files are just ONE body and ONE
                <code>opt_s</code> definition. if a set of options can be fundamentally
                grouped by their functionality, they can be a subdirectory to
                <code>cli/</code> itself.
            </p>

            <p>
                these only have code for logic THEY specifically need, if an option does
                something that a utility can do, that utility goes to <code>core/</code>.
                for example: printing blog data is responsibility of the option body but
                fetching something from the internet may belong to <code>core/</code> if
                and only if used more than once.
            </p>

        </section>
        <section>
            
            <h2>in <code>core/</code>:</h2>
            <p>
                <code>funcx.c</code>: we have business logic for our program, utilities,
                general functions, etc.
            </p>

            <p>
                <code>init.c</code>, <code>run.c</code>, <code>die.c</code>: these just
                specify the stages of the lifecycle of a program.
            </p>

            <p>
                <code>init.c</code> should run <code>initcli()</code>, add the options,
                add the command name, the help aliases, the footer, the program
                description, etc. it should set debug/laidback/nonopt modes. most things
                here should probably be <code>static</code>.
            </p>

            <p>
                <code>run.c</code> should run <code>runcli()</code>, it should be a loop
                if the program is supposed to be interactive, it should react to context
                changes, propagate them to the <code>core/</code> part of the program,
                etc.
            </p>

            <p>
                <code>die.c</code> should run <code>freecli()</code>, free context if heap
                allocated, save any permanent states, and make sure no memory leaks exist.
            </p>

        </section>
        <section>
            
            <h2>in <code>include/</code>:</h2>
            <p>
                scripts in <code>cli/</code> and <code>core/</code> should directly
                correspond to these headers, i would define the <code>cli_s</code> struct
                and <code>ret_e</code> body inside the header and not the script to make
                sure these headers reads like the cover of an option.
            </p>

            <p>
                ok, so this is why this seemed really clean to <q>me</q>, at least. this
                structure acknowledges that ezcli is just a tunnel to between a good
                program and the user, not something that wraps the program itself.
            </p>
        </section>

        <section>
            
            <p>ezcli has moving parts:</p>
            <ul>
                <li>cli information</li>
                <li>option information</li>
                <li>context information</li>
            </ul>
        </section>

        <section>
            <p>
                this project structure mentally unifies them but structurally isolates
                them. and this is what's necessary for a project to be scalable using
                ezcli. because just like functions, files should also almost always have a
                single responsiblity.
            </p>

            <p>
                since each part is correctly split into its responsibilities, a person
                reading a part of that project will never be confused about what they're
                reading.
            </p>

            <p>
                they will know for sure, that when they go to <code>ctx/</code>, they will
                see the blueprint for context information, that when they go to
                <code>cli/</code>, they will see those contexts initialized and they will
                see options being specific, but using <code>core/</code> functionality as
                building blocks.
            </p>

            <p>
                init-&gt;live-&gt;die is also what 99.9999% of what every program does.
                which is what
                <code>main.c</code> should be doing.
            </p>

            <p>
                note: ezcli doesn't know your project structure. nor does it care. you are
                free do whatever you're comfortable doing.
            </p>
        </section>
  </body>
</html>
